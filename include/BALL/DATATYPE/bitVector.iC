// $Id: bitVector.iC,v 1.18 2000/12/16 21:27:13 amoll Exp $

BALL_INLINE 
BALL::Size BitVector::getSize() const
	throw()
{
  return size_;
}

BALL_INLINE
Bit::Bit(const BitVector* const bit_vector, Index index) 
	throw(Exception::NullPointer, Exception::IndexUnderflow, Exception::IndexOverflow)
{
	if (bit_vector == 0)
	{
		throw Exception::NullPointer(__FILE__, __LINE__);
	}

	if (index < (Index) - bit_vector->getSize() )
	{
		throw Exception::IndexUnderflow(__FILE__, __LINE__);
	}

	if (index >= (Index) bit_vector->getSize())
	{
		throw Exception::IndexOverflow(__FILE__, __LINE__);
	}

	bitvector_					= const_cast<BitVector *> (bit_vector);
	index_							= index;
	bitvector_muteable_ = false;
}

BALL_INLINE
Bit::Bit(BitVector* bit_vector, Index index) 
	throw(Exception::NullPointer)
{
	if (bit_vector == 0)
	{
		throw Exception::NullPointer(__FILE__, __LINE__);
	}

	bitvector_					= bit_vector;
	index_							= index;
	bitvector_muteable_ = true;

}

BALL_INLINE
Bit::~Bit()
	throw()
{
}

BALL_INLINE
void Bit::clear() 
	throw()
{
	bitvector_					= 0;
	index_							= 0;
	bitvector_muteable_ = false;
}


BALL_INLINE
BitVector::BlockType BitVector::mask_(Index index) const
	throw()
{
	return (1 << (index & BALL_BLOCK_MASK));
}

BALL_INLINE 
void BitVector::clear()
	throw()
{
	setSize(0, false);
}

BALL_INLINE 
BitVector& BitVector::operator = (const BitVector& bit_vector)
  throw(Exception::OutOfMemory)
{
  set(bit_vector);
  return *this;
}

BALL_INLINE 
const BitVector& BitVector::operator = (const char* bit_string)
  throw(Exception::OutOfMemory)
{
  set(bit_string);
  return *this;
}

BALL_INLINE 
void BitVector::get(BitVector& bit_vector, bool deep) const
  throw(Exception::OutOfMemory)
{
  bit_vector.set(*this, deep);
}

BALL_INLINE 
BALL::BitVector::BlockType* BitVector::getBitSet()
	throw()
{
  return bitset_;
}

BALL_INLINE 
const BALL::BitVector::BlockType* BitVector::getBitSet() const
	throw()
{
  return bitset_;
}

BALL_INLINE 
BitVector BitVector::operator | (const BitVector& bit_vector)
  throw(Exception::OutOfMemory)
{
  BitVector temp(*this);
  temp.bitwiseOr(bit_vector);
  return temp;
}

BALL_INLINE 
BitVector& BitVector::operator |= (const BitVector &bit_vector)
  throw(Exception::OutOfMemory)
{
  bitwiseOr(bit_vector);
  return *this;
}

BALL_INLINE 
BitVector BitVector::operator & (const BitVector& bit_vector)
  throw(Exception::OutOfMemory)
{
  BitVector temp(*this);
  temp.bitwiseAnd(bit_vector);
  return temp;
}

BALL_INLINE 
BitVector& BitVector::operator &= (const BitVector &bit_vector)
  throw(Exception::OutOfMemory)
{
  bitwiseAnd(bit_vector);
  return *this;
}

BALL_INLINE 
BitVector BitVector::operator ^ (const BitVector& bit_vector)
  throw(Exception::OutOfMemory)
{
  BitVector temp(*this);
  temp.bitwiseXor(bit_vector);
  return temp;
}

BALL_INLINE 
BitVector& BitVector::operator ^= (const BitVector &bit_vector)
  throw(Exception::OutOfMemory)
{
  bitwiseXor(bit_vector);
  return *this;
}

BALL_INLINE 
BitVector BitVector::operator ~ ()
  throw(Exception::OutOfMemory)
{
  BitVector temp(*this);
  temp.toggle();
  return temp;
}

BALL_INLINE 
bool BitVector::operator != (const BitVector &bit_vector) const
	throw()
{
  return !(*this == bit_vector);
}

BALL_INLINE 
bool BitVector::isValid() const
	throw()
{
  return (bitset_ != 0);
}

BALL_INLINE
Bit BitVector::operator [] (Index index)
  throw(Exception::IndexUnderflow, Exception::OutOfMemory)
{
	block_(index);
	return Bit(this, index);
}

BALL_INLINE
bool BitVector::getBit(Index index)
	throw(Exception::IndexUnderflow, Exception::OutOfMemory)
{
	validateIndex_(index);
	return (bool)((bitset_[block_(index)] & mask_(index)) != 0);
}

BALL_INLINE
bool BitVector::getBit(Index index) const
  throw(Exception::IndexUnderflow, Exception::IndexOverflow)
{
	validateIndex_(index);
	BitVector* const  const_this = const_cast<BitVector *>(this);
	return const_this->getBit(index);
}

BALL_INLINE
bool BitVector::operator [] (Index index) const
  throw(Exception::IndexUnderflow, Exception::IndexOverflow)
{
	return getBit(index);
}
 
BALL_INLINE
void BitVector::setBit(Index index, bool value)
	throw(Exception::IndexUnderflow, Exception::OutOfMemory)
{
	validateIndex_(index);

	if (value == true)
	{
		bitset_[block_(index)] |= mask_(index);
	}
	else 
	{
		bitset_[block_(index)] &= ~mask_(index);
	}
}

BALL_INLINE
void BitVector::toggleBit(Index index)
	throw(Exception::IndexUnderflow, Exception::OutOfMemory)
{
	validateIndex_(index);
	bitset_[block_(index)] ^= mask_(index);
}

BALL_INLINE
bool Bit::operator == (bool bit) const 
	throw(Exception::NullPointer)
{
	if (bitvector_ == 0)
	{
		throw Exception::NullPointer(__FILE__, __LINE__);
	}

	return bitvector_->getBit(index_) == bit;
}

BALL_INLINE
bool Bit::operator != (bool bit) const 
	throw(Exception::NullPointer)
{
	if (bitvector_ == 0)
	{
		throw Exception::NullPointer(__FILE__, __LINE__);
	}
	
	return bitvector_->getBit(index_) != bit;
}

BALL_INLINE
bool Bit::operator == (const Bit& bit) const 
	throw()
{
	return (bitvector_					== bit.bitvector_					&& 
					index_							== bit.index_							&&
					bitvector_muteable_	== bit.bitvector_muteable_	);
}

BALL_INLINE
bool Bit::operator != (const Bit& bit) const 
	throw()
{
	return !(*this == bit);
}

BALL_INLINE
Bit::operator bool() const 
	throw(Exception::NullPointer)
{
	if (bitvector_ == 0)
	{
		throw Exception::NullPointer(__FILE__, __LINE__);
	}

	return bitvector_->getBit(index_);
}

BALL_INLINE
const Bit& Bit::operator = (const Bit& bit)	
	throw()
{
	bitvector_					= bit.bitvector_;
	index_							= bit.index_;
	bitvector_muteable_	= bit.bitvector_muteable_;

	return *this;
}

BALL_INLINE
const Bit& Bit::operator = (const bool bit)
	throw(Exception::NullPointer, IllegalOperation)
{
	if (bitvector_ == 0)
	{
		throw Exception::NullPointer(__FILE__, __LINE__);
	}

	if (bitvector_muteable_ == false)
	{
		throw IllegalOperation(__FILE__, __LINE__);
	}

	bitvector_->setBit(index_, bit);
	return *this;
}
